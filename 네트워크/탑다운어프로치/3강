3.1 Introdcution and Transport-Layer services


다른 호스트들 사이에서 가동되는 애플리케이션 프로세스의 논리적인 통신



물리적으로 간 것이 아니라, 보낸 것이 갔는지 안 갔는지만 확인한다.



Sender:메시지를 패킷으로 나눠서 네트워크 레이어로 넘김

Reciever: 분할되서 온 패킷들을 다시 뭉침



3.1.1 Relationship Between Transport and Network Layers
애플리케이션의 내용이 무엇이든 트렌스포트 레이어는 보내는 것에만 집중한다.



3.1.2 Overview of the Transport Layer in the Internet
UDP: 신뢰X, 간단한 프로토콜

No-frills extension of best-effort IP

TCP: 신뢰O, 복잡한 프로토콜

Congestion control 데이터 꼬이는 것 통제

Connection setup 연결 잘되게 함

Flow control 결점 컨트롤



->딜레이 통제, 대역폭 보장





3.2 Multiplexing and Demultiplexing
Socket:운영체제 안에 구현되어 있는 네트워크 프로그래밍을 쓰게 한다.



Multiplexing: 여러 곳에 있는 것을 하나로 모음

Demultiplexing: 한 곳에 있는 곳을 여러개로 나눠줌



어떻게 어느 컴퓨터로 보내는지가 중요하다. 각각 데이터그램은 IP 주소를 갖고 있다.




소스의 패킷에 소스의 포트, 데스티네이션 포트 등이 있어서 찾아갈 수 있다.



소스포트가 필요한 이유?

1) 누구로부터 온 정보인지 알아야한다

2) 양방향 소통





3.4 Principles of Reliable Data transfrer
Reliable data transfer

redt_send(): 신뢰롭게 데이터를 넘겨달라고 요구함

udt_send(): 신뢰롭진 않지만 보내줘

deliver_data(): 데이터 받은 후 보내는것

rdt_rcv():데이터 받았다






reliable data transfer protocol이 서비스의 추상화를 책임지며, 신뢰성있는 전달을 담당한다.





3.4.1 Building a Reliable Data Transfer Protocol
FSM(finite-state-machine)모델. 

보내면 결과가 있음



Reliable Data transfer over a Channel with Bit Errors

에러가 없으면 트렌스포트 레이어는 할 일이 없다.

그러나 실제로는 신호가 바뀐다. 그렇기에 에러비트를 같이 보낸다.



checksum이라는 에러분류 코드를 보내는데, 이 합이 변경됐다면 다시 정보를 보내라고 요청을 한다.

ACK가 정보를 잘 받았을 때 보내는 코드다.

만약 ACK가 일정시간 오지 않는다면 정보를 정확히 보내는데 실패했다고 볼 수 있다.

그러면 이 때 타이머를 두고 재전송을 한다.





3.4.2 Pipelined Reliable Data Transfer Protocols



신호를 보내고 다시 ack를 받을 때 까지 기다리면 그 동안 sender가 노는 시간이 너무 길다.

이 시간을 어떻게 처리해야 할까?



->한번에 연속해서 보내고 연속해서받는다



윈도우 크기가 6이면, 0,1,2만 처음에 3개를 보낸다.

0에 대해 ack을 받으면 1,2,3만 신경 쓰고, 1에 대해 받으면 2,3,4를 받는다.



3.4.3 Go-back-N(GBN)


culmulative ACK



1,2,3  // 5, 7

을 받았다면, 3을 받았다고 응답한다.



연속적으로 된 것만 응답한다.





Selective repeat

각각의 ack을 보낸다.

